function [ firm_data, tax_residual, output_residual, output_aggregates, ...
    pollution_aggregates, employment_aggregates, welfare, surplus ] =   ...
    runSimulationSingle( parameters, debug )
% =========================================================================
% RUNSIMULATIONSINGLE runs a simulation given a single set of taxes and 
% prices with debug outputs to help find the optimal taxes/prices
% =========================================================================
% INPUT ARGUMENTS: (enter any number of pairs)
%   parameters             (struct) generated by loadParameters
%   debug                  (struct) set debug.taxes to true to print the
%                                   optimal theoretical tax (endogenous), 
%                                   and set debug.prices to true for the
%                                   difference between quantity supplied
%                                   and demanded
%                                   to true to print the optimal prices
% =========================================================================
% OUTPUT:
%   firm_data              (vector) contains the number of firms 
%                                   producing, investing, and idle in
%                                   that order
%   tax_residual           (vector) contains the difference in the current
%                                   tax and the partial eq optimal tax
%   output_residual        (vector) contains the differences, for each 
%                                   period between Q_s and Q_d
%   output_aggregates      (matrix) output in period 1a, 2a, and 2b for
%                                   each tax in period 1 and period 2 and
%                                   for each price in period 1a, 2a, and
%                                   2b in that order
%   pollution_aggregates   (matrix) same format as output_aggregates but 
%                                   with pollution
%   employment_aggregates  (matrix) same format as output_aggregates but 
%                                   with employment
%   welfare                (matrix) same format as output_aggreagtes but
%                                   with welfare, also contains total
%                                   social welfare denoted as V in the
%                                   paper
%   surplus                (matrix) same format as output_aggreagtes but
%                                   with producer and consumer surplus
% =========================================================================


%% Unpack parameters

% Exogenous
beta_hat  = parameters.beta_hat;
price     = parameters.price;
emp       = parameters.emp; 
I_1       = parameters.I_1;
I_2       = parameters.I_2;
gamma     = parameters.gamma;
rho       = parameters.rho;
delta     = parameters.delta;
alpha     = parameters.alpha;
xi        = parameters.xi;
psi       = parameters.psi;
elas_D    = parameters.elas_D;
a1        = parameters.a1;
a2        = parameters.a2;

% Endogenous
t_1a  = parameters.taxes_1a;
t_2a  = parameters.taxes_2a;
p_1a = parameters.prices_1a;
p_2a = parameters.prices_2a;
p_2b = parameters.prices_2b;


%% Supply

% Find total number of firms and normalization factor "A"
temp_func   = @(x,beta) beta.^(a1 - 1) .* x.^a2;          
A           = emp/integral2(temp_func, 0, beta_hat, 0, price);
total_firms = integral2(@(beta,x)  A .* beta.^(a1 - 1) .*  x.^(a2 - 1), ...
                            0, beta_hat, 0, price);

fun =    @(beta,x)  A .* beta.^(a1 - 1) .*  x.^(a2 - 1);
pollut = @(beta,x)  A .* beta.^a1       .*  x.^(a2 - 1);
employ = @(beta,x)  A .* beta.^(a1 - 1) .*  x.^a2;


%% Demand: P = a + b*Q

% assume demand with given elasticity at current price
Q_temp = total_firms; % all firms supplying at current price with no tax
P_temp = price;       % current market price
b = elas_D / (P_temp/ Q_temp);
a = Q_temp - b*P_temp;

% demand curves
demand     = @(p) a + b*p;
demand_inv = @(q) (q-a)/b;


%% Main

% pre-alloc data arrays
output_aggregates     = zeros(3);
pollution_aggregates  = zeros(3);
employment_aggregates = zeros(3);
welfare               = zeros(4); 

% residual output for prices (difference between quantity supplied
% and quantity demanded)
output_diff_1a = 0;
output_diff_2a = 0;
output_diff_2b = 0;
                    
% Simulation                 
[ aggregates_1a, aggregates_2a, aggregates_2b ] =  ...
sumRegionParallel(parameters, fun, pollut, employ, ...
t_1a, t_2a, p_1a, p_2a, p_2b);

% Reimann Integral Aggregates   
pollution_1a = aggregates_1a(1,:);
pollution_2a = aggregates_2a(1,:);
pollution_2b = aggregates_2b(1,:);

employment_1a = aggregates_1a(2,:);
employment_2a = aggregates_2a(2,:);
employment_2b = aggregates_2b(2,:);

output_1a     = aggregates_1a(3,:);
output_2a     = aggregates_2a(3,:);
output_2b     = aggregates_2b(3,:);

investment_1a = aggregates_1a(4,:);
investment_2a = aggregates_2a(4,:);
investment_2b = 0;

pollution_stock_1a = pollution_1a;
pollution_stock_2a = pollution_1a*(1 - psi) + pollution_2a;
pollution_stock_2b = pollution_1a*(1 - psi) + pollution_2b;

tax_revenue_1a = t_1a*pollution_1a;
tax_revenue_2a = t_2a*pollution_2a;
tax_revenue_2b = 0*pollution_2b;

% Producer surplus
producer_surplus_1a = demand(p_1a)*p_1a - ...
    employment_1a - tax_revenue_1a - investment_1a;
producer_surplus_2a = demand(p_2a)*p_2a - ...
    employment_2a - tax_revenue_2a - investment_2a;
producer_surplus_2b = demand(p_2b)*p_2b - ...
    employment_2b - tax_revenue_2b - investment_2b;

% Consumer surplus (linear demand)
consumer_surplus_1a = (demand_inv(0) - p_1a)*demand(p_1a)/2;
consumer_surplus_2a = (demand_inv(0) - p_2a)*demand(p_2a)/2;
consumer_surplus_2b = (demand_inv(0) - p_2b)*demand(p_2b)/2;

% Welfare
welfare_1a = consumer_surplus_1a + producer_surplus_1a + tax_revenue_1a - xi*pollution_stock_1a^2;
welfare_2a = consumer_surplus_2a + producer_surplus_2a + tax_revenue_2a - xi*pollution_stock_2a^2;
welfare_2b = consumer_surplus_2b + producer_surplus_2b + tax_revenue_2b - xi*pollution_stock_2b^2;
social_welfare = (welfare_1a + delta*(alpha*welfare_2a + (1-alpha)*welfare_2b));

% Aggregates
output_aggregates = [output_1a, output_2a, output_2b];
pollution_aggregates = [pollution_stock_1a, pollution_stock_2a, pollution_stock_2b];
employment_aggregates = [employment_1a, employment_2a, employment_2b];
welfare = [social_welfare, welfare_1a, welfare_2a, welfare_2b];

surplus = [producer_surplus_1a, producer_surplus_2a, ...
    producer_surplus_2b, consumer_surplus_1a, ...
    consumer_surplus_2a, consumer_surplus_2b];

% Difference quantity demanded and quantity supplied
output_diff_1a = output_1a - demand(p_1a);
output_diff_2a = output_2a - demand(p_2a);
output_diff_2b = output_2b - demand(p_2b);


%% Residuals and Debug outputs

% assuming partial equillibrium (?), changes in taxes would affect
% pollution stock which changes the marginal damage of pollution
% and thus the optimal taxes
opt_tax_1a = 2*xi*pollution_stock_1a ...
              + delta*(1-psi)*(alpha*2*xi*pollution_stock_2a ...
              + (1-alpha)*2*xi*pollution_stock_2b) ...
              + delta*(1-alpha)*2*xi*pollution_stock_2b;
opt_tax_2a = 2*xi*pollution_stock_2a;
    
if debug.taxes  
    
    disp('Difference between optimal taxes and current taxes: ')
    fprintf(['    Period 1A: \n        Optimal Tax: %f\n        ' ...
        'Current tax: %f\n'], opt_tax_1a, t_1a)
    fprintf(['    Period 2A: \n        Optimal Tax: %f\n        ' ...
        'Current tax: %f\n'], opt_tax_2a, t_2a)
                      
end

if debug.prices
    
    % prints differences in output given current prices
    disp('Difference between quantity supplied and demanded: ')
    fprintf('    Period 1A: %f \n    Period 2A: %f \n    Period 2B: %f\n', ...
        output_diff_1a, output_diff_2a, output_diff_2b)
    
end

tax_residual    = [t_1a - opt_tax_1a, t_2a - opt_tax_2a];
output_residual = [output_diff_1a, output_diff_2a, output_diff_2b]; 


%% Firm Analysis

% firms producing or investing
firms_active = [aggregates_1a(3), aggregates_2a(3), aggregates_2b(3)];

% firms investing = sum (investment_i)/(investment_cost_i)
firms_investing = [aggregates_1a(4)/I_1, aggregates_2a(4)/I_2, aggregates_2b(4)/I_2];

% firms producing without investing
firms_producing = firms_active - firms_investing;

% firms not producing
firms_idle      = total_firms - firms_active;

firm_data = [firms_producing; firms_investing; firms_idle];
                    
