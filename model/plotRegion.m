function [ ] = plotRegion(parameters, target, points, markers, ...
                            error_tol, inBW)
% =========================================================================
% PLOTREGIONBW plots the survival region in black and white by splitting up
% the survival region into a given number of points and then drawing 
% colored or b/w lines to denote decisions; the start and end of each line
% is determined by doing a binary search for the borders of the survival
% region at a given beta
% =========================================================================
% INPUT ARGUMENTS:
%   parameters             (struct)  generated by loadParameters
%   target                 (axes)    target a subplot of the current figure
%                                    by calling subplot(x,y,plot_num)
%   points                 (int)     number of points to draw lines over,
%                                    more points increases visual accuracy 
%                                    but takes more time 
%   markers                (int)     number of markers for x and beta to
%                                    place on the plot, eg setting to 10
%                                    will result in 100 points
%   error_tol              (numeric) error of approximation of survival
%                                    region borders
%   inBW                   (boolean) set to true for black and white plots           
% =========================================================================
% OUTPUT: Updates targetted subplot
% =========================================================================

%% Prepare plot

cla(target);
hold(target, 'on');


%% Unpack parameters

% Exogenous
beta_hat  = parameters.beta_hat;
price     = parameters.price;
emp       = parameters.emp; 
I_1       = parameters.I_1;
I_2       = parameters.I_2;
gamma     = parameters.gamma;
rho       = parameters.rho;
delta     = parameters.delta;
alpha     = parameters.alpha;
xi        = parameters.xi;
psi       = parameters.psi;
elas_D    = parameters.elas_D;
a1        = parameters.a1;
a2        = parameters.a2;

% Endogenous
t_1a  = parameters.taxes_1a;
t_2a  = parameters.taxes_2a;
p_1a  = parameters.prices_1a;
p_2a  = parameters.prices_2a;
p_2b  = parameters.prices_2b;


%% Define integration range

x_range = linspace(0, max([p_1a, p_2a, p_2b]), points);
beta_range  = linspace(0, beta_hat, points);


%% Main

for beta_ind = 1:points
    
    beta = beta_range(beta_ind); 
    
    % get optimal decision at current beta and x = 0
    [ ind, ind_I_2a, ind_N_2a, ind_I_2b, ind_N_2b ] = ...
        findOptimalDecision(0, beta, I_1, I_2, gamma, rho,     ...
        delta, alpha, t_1a, t_2a, p_1a, p_2a, p_2b); 
    [ decisionvector ] = createDecisionVector( ind, ind_I_2a, ...
        ind_N_2a, ind_I_2b, ind_N_2b );
    
    x_max = max(x_range);
    x_upper = 0;
    
    % while producing at current (beta, x) still proftiable
    while decisionvector(1) ~= 1 
        
        % check higher x values until a different decision is found
        x_lower = x_upper;
        x_upper = x_max;
        
        % binary search
        [ x_upper, decisionvector, ~ ] = binarySearchDecision(x_lower, ...
        x_upper, beta, I_1, I_2, gamma, rho, delta, alpha, t_1a, t_2a,     ...
        p_1a, p_2a, p_2b, error_tol);
        
        % set line color
        if all(decisionvector == [1,1,1])      % black = no invest
            mcolor = [1 1 1]/1e6;
        elseif all(decisionvector == [2,1,2])  % cyan = produce(1), drop second(a), produce second(b)
            mcolor = [0 1 1];
        elseif all(decisionvector == [2,3,2])  % blue = produce(1), invest second(a), produce second(b)
            mcolor = [0 0 1];
        elseif all(decisionvector == [2,2,2])  % green = produce(1), produce second (both)
            mcolor = [0 1 0];
        elseif all(decisionvector == [3,2,2])  % red  = invest(1), produce second (both)
            mcolor = [1 0 0];
        elseif all(decisionvector == [3,1,2])  % magenta = invest(1), drop second (a), produce second (b)
            mcolor = [1 0 1];
        elseif all(decisionvector == [2,2,1])  % orange = produce(1), produce second (a), drop second (b)
            mcolor = [1 0.5 0];
        else                                 % yellow = ??
            mcolor = [1 1 0];
        end
        
        if inBW 
            mcolor = brighten(rgb2gray(mcolor), 0.9);
        end
        
        %plot(beta, x_upper, 'Marker', '.', 'Color', [0.5 0.5 0.5])
        if (mod(beta_ind, 1) == 0 || points < 1000)
            plot([beta, beta], [x_lower, x_upper], 'Color', mcolor, ...
                'LineWidth',2) 
        end
        
    end
                    
end


%% Add points

beta_range2   = linspace(beta_hat*0.02, beta_hat*0.98, markers);
x_range2      = linspace(max(x_range)*0.02, max(x_range)*0.98, markers);

for i = 1:length(beta_range2)
    
    beta = beta_range2(i);
    
    for j = 1:length(x_range2)
        
        x = x_range2(j);
        
        [ ind, ind_I_2a, ind_N_2a, ind_I_2b, ind_N_2b ] = ...
            findOptimalDecision(x, beta, I_1, I_2, gamma, rho,     ...
            delta, alpha, t_1a, t_2a, p_1a, p_2a, p_2b);
        [ decisionvector ] = createDecisionVector(ind, ind_I_2a, ...
                    ind_N_2a, ind_I_2b, ind_N_2b);
                
        if all(decisionvector == [1,1,1])      % idle
            mtype = '.';
        elseif all(decisionvector == [2,1,2])  % produce(1), drop second(a), produce second(b)
            mtype = '*';
        elseif all(decisionvector == [2,3,2])  % produce(1), invest second(a), produce second(b)
            mtype = 'x';
        elseif all(decisionvector == [2,2,2])  % produce(1), produce second (both)
            mtype = 'o';
        elseif all(decisionvector == [3,2,2])  % invest(1), produce second (both)
            mtype = '+';
        elseif all(decisionvector == [3,1,2])  % invest(1), drop second (a), produce second (b)
            mtype = '^';
        elseif all(decisionvector == [2,2,1])  % produce(1), produce second (a), drop second (b)
            mtype = 'v';
        else                                   % something else
            mtype = 's';
        end
        
        plot(beta, x, 'Marker', mtype, 'Color', 'k', 'MarkerSize', 4)
        
    end
    
end

end


%% Auxiliary functions
    
function [ ind, ind_I_2a, ind_N_2a, ind_I_2b, ind_N_2b ] = ...
    findOptimalDecision(x, beta, I_1, I_2, gamma, rho,     ...
    delta, alpha, t_1a, t_2a, p_1a, p_2a, p_2b)
    % =====================================================================
    % FINDOPTIMALDECISION gets a firms optimal decision given a set of
    % params, x, and beta
    % =====================================================================

    % Max profit in period 2a for firms that have invested in period 1
    [pi_I_2a, ind_I_2a] = max([0, p_2a - (1+rho)*x - ...
     t_2a*(1-gamma)*beta]);
    % Noninvesting max profit in period 2a
    [pi_N_2a, ind_N_2a] = max([0, p_2a - x - t_2a*beta, p_2a - x - ...
     t_2a*(1-gamma)*beta - I_2]);

    % Max profit in period 2b for firms that have invested in period 1
    [pi_I_2b, ind_I_2b] = max([0, p_2b - (1+rho)*x]);
    % Noninvesting max profit in period 2b
    [pi_N_2b, ind_N_2b] = max([0, p_2b - x]);

    % Present value expected profit for a firm investing in period 1
    pi_I_1a = p_1a - (1+rho)*x - t_1a*(1-gamma)*beta - I_1 + delta* ...
              (alpha*(pi_I_2a) + (1-alpha)*(pi_I_2b));

    % Present value expected profit for a firm producing in period 1
    pi_N_1a = p_1a - x - t_1a*beta + delta*(alpha*(pi_N_2a) + (1-alpha)*(pi_N_2b));    


    % Firms may exit, produce in period 1, or invest in period 1
    profit_mat = [0, pi_N_1a, pi_I_1a];

    [~, ind] = max(profit_mat);
        
end


function [ decisionvector ] = createDecisionVector(ind, ind_I_2a, ...
            ind_N_2a, ind_I_2b, ind_N_2b)
    % =====================================================================
    % CREATEDECISIONVECTOR converts a set of optimal decisions into a
    % vector representation of the optimal decision for a firm
    % =====================================================================
        
    % in each period, 1 = drop, 2 = produce, 3 = invest
    
    % by default 1 => not producing first period
    decisionvector = ones(1,3); 
    
    if ind == 2 % firms not investing first period
        
        decisionvector = [ind, ind_N_2a, ind_N_2b];
        
    elseif ind == 3 % firms investing first period
        
        decisionvector = [ind, ind_I_2a, ind_I_2b];
        
    end
    
end

function [ x_upper, decisionvector, debug ] = binarySearchDecision(    ...
    x_lower, x_upper, beta, I_1, I_2, gamma, rho, delta, alpha, t_1a,  ...
    t_2a, p_1a, p_2a, p_2b, error_tol)
    % =====================================================================
    % BINARYSEARCHDECISION searches the range between x_lower and x_upper
    % for the boundary where the decision at some output x is different 
    % then the inital decision at x_lower; essentially it scans upwards 
    % from a given x for the next survival region boundary
    % =====================================================================

    debug = [x_lower, (x_lower + x_upper)/2, x_upper];

    % get base decision
    [ ind, ind_I_2a, ind_N_2a, ind_I_2b, ind_N_2b ] =                 ...
        findOptimalDecision(x_lower, beta, I_1, I_2, gamma, rho,      ...
        delta, alpha, t_1a, t_2a, p_1a, p_2a, p_2b);
    [ decisionvector ] = createDecisionVector(ind, ind_I_2a,           ...
        ind_N_2a, ind_I_2b, ind_N_2b);
    decision_base = decisionvector;

    while true

        % get decision at x maximum
        [ ind, ind_I_2a, ind_N_2a, ind_I_2b, ind_N_2b ] =              ...
            findOptimalDecision(x_upper, beta, I_1, I_2, gamma, rho,   ...
            delta, alpha, t_1a, t_2a, p_1a, p_2a, p_2b);
        [ decisionvector ] = createDecisionVector(ind, ind_I_2a, ...
            ind_N_2a, ind_I_2b, ind_N_2b);
        decision_max = decisionvector;

        % get decision at x minimum
        [ ind, ind_I_2a, ind_N_2a, ind_I_2b, ind_N_2b ] =              ...
            findOptimalDecision(x_lower, beta, I_1, I_2, gamma, rho,   ...
            delta, alpha, t_1a, t_2a, p_1a, p_2a, p_2b);
        [ decisionvector ] = createDecisionVector(ind, ind_I_2a,       ...
            ind_N_2a, ind_I_2b, ind_N_2b);
        decision_min = decisionvector;

        % get decision at x mean
        x_mid = mean([x_lower, x_upper]);
        [ ind, ind_I_2a, ind_N_2a, ind_I_2b, ind_N_2b ] =              ...
            findOptimalDecision(x_mid, beta, I_1, I_2, gamma, rho,     ...
            delta, alpha, t_1a, t_2a, p_1a, p_2a, p_2b);
        [ decisionvector ] = createDecisionVector(ind, ind_I_2a,       ...
            ind_N_2a, ind_I_2b, ind_N_2b);
        decision_mid = decisionvector;

        if x_upper - x_lower < error_tol
            decisionvector = decision_min;
            break;
        elseif all(decision_mid == decision_base)
            x_lower = x_mid;
            x_mid   = mean([x_lower, x_upper]);
        else
            x_upper = x_mid;
            x_mid   = mean([x_lower, x_upper]);
        end
        debug = [debug; x_lower, x_mid, x_upper];
    end

end
