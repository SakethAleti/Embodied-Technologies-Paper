function [ aggregates_1a, aggregates_2a, aggregates_2b ] =            ...
    sumRegionParallel(parameters, fun, pollut, employ, t_1a, t_2a,    ...
    p_1a, p_2a, p_2b)
% =========================================================================
% SUMREGION performs a Riemann integration over the survival region
% =========================================================================
% INPUT ARGUMENTS:
%   parameters             (struct) generated by loadParameters
%   fun                    (func)   output is the number of firms at a
%                                   given x and beta
%   pollut                 (func)   output is the total pollution created
%                                   by the firms at a given x and beta
%   employ                 (func)   output is the total employment needed
%                                   by the firms at a given x and beta
%   t_1a                   (scalar) tax in period 1 with party A
%   t_2a                   (scalar) tax in period 2 with party A
%   t_2b                   (scalar) tax in period 2 with party B
%   p_1a                   (scalar) price in period 1 with party A
%   p_2a                   (scalar) price in period 2 with party A
%   p_2b                   (scalar) price in period 2 with party B
% =========================================================================
% OUTPUT:
%   aggregates_period      (matrix) contains the total pollution,
%                                   employment, output, and investment in
%                                   that order for the given period
%                                   and firms' decision, either produce or
%                                   invest as the second dimension
% =========================================================================

%% Unpack params 

beta_hat  = parameters.beta_hat;
price     = parameters.price;
emp       = parameters.emp; 
I_1       = parameters.I_1;
I_2       = parameters.I_2;
gamma     = parameters.gamma;
rho       = parameters.rho;
delta     = parameters.delta;
alpha     = parameters.alpha;


%% Pre-alloc arrays

% columns are {pollution, employment, output, investment}
aggregates_1a = zeros(4, 1);
aggregates_2a = zeros(4, 1);
aggregates_2b = zeros(4, 1);


%% Define integration range

points = 200;
x_range     = linspace(0, max([p_1a, p_2a, p_2b]), points);
beta_range  = linspace(0, beta_hat, points);
b_int       = beta_range(2) - beta_range(1);

      
%% Simulation

parfor i = 1:length(beta_range)
    
    beta = beta_range(i);
    
    % functions in terms of x with the given beta 
    %fun_x    = @(x) fun(beta, x);
    %pollut_x = @(x) pollut(beta, x);
    %employ_x = @(x) employ(beta, x);
    
    % get optimal decision at current beta and x = 0
    [ ind, ind_I_2a, ind_N_2a, ind_I_2b, ind_N_2b ] = ...
        findOptimalDecision(0, beta, parameters, t_1a, t_2a, p_1a, ...
        p_2a, p_2b); 
    [ decisionvector ] = createDecisionVector( ind, ind_I_2a, ...
        ind_N_2a, ind_I_2b, ind_N_2b );
    
    
    x_max = max(x_range);
    x_upper = 0;
    
    % while producing at current (beta, x) still proftiable
    while decisionvector(1) ~= 1 
        
        % check higher x values until a different decision is found
        % binary search
        
        x_lower = x_upper;
        x_upper = x_max;
        error_tol = 0.01;
        [ x_upper, decisionvector, ~ ] = binarySearchDecision(x_lower, ...
        x_upper, beta, parameters, t_1a, t_2a,     ...
        p_1a, p_2a, p_2b, error_tol);
    
        if decisionvector(1) ~= 1
            
            % if we are producing find outputs
            pollution  = integral(@(x) pollut(beta, x), x_lower, x_upper)*b_int;
            employment = integral(@(x) employ(beta, x), x_lower, x_upper)*b_int;
            output     = integral(@(x) fun(beta, x),    x_lower, x_upper)*b_int;
            
            % and update aggregates, this way needed to work with parfor
            [ data_1a, data_2a, data_2b ] =           ...
             updateAggregates( decisionvector, 0, 0, 0, ...
             gamma, rho, I_1, I_2, pollution, employment, output);
            aggregates_1a = data_1a + aggregates_1a;
            aggregates_2a = data_2a + aggregates_2a;
            aggregates_2b = data_2b + aggregates_2b;
            
        end
        
    end
    
end
 
end

%% Auxillary Functions

function [ decisionvector ] = createDecisionVector(ind, ind_I_2a, ...
            ind_N_2a, ind_I_2b, ind_N_2b)
        
    % by default 1 => not producing first period
    decisionvector = ones(1,3); 
    
    if ind == 2 % firms not investing first period
        
        decisionvector = [ind, ind_N_2a, ind_N_2b];
        
    elseif ind == 3 % firms investing first period
        
        decisionvector = [ind, ind_I_2a, ind_I_2b];
        
    end
    
end

function [ x_upper, decisionvector, debug ] = binarySearchDecision(    ...
    x_lower, x_upper, beta, parameters, t_1a,  ...
    t_2a, p_1a, p_2a, p_2b, error_tol)

    beta_hat  = parameters.beta_hat;
    price     = parameters.price;
    emp       = parameters.emp; 
    I_1       = parameters.I_1;
    I_2       = parameters.I_2;
    gamma     = parameters.gamma;
    rho       = parameters.rho;
    delta     = parameters.delta;
    alpha     = parameters.alpha;

    debug = [x_lower, (x_lower + x_upper)/2, x_upper];

    % get base decision
    [ ind, ind_I_2a, ind_N_2a, ind_I_2b, ind_N_2b ] =            ...
    findOptimalDecision(x_lower, beta, parameters, t_1a, t_2a,   ...
        p_1a, p_2a, p_2b);
    [ decisionvector ] = createDecisionVector(ind, ind_I_2a, ...
            ind_N_2a, ind_I_2b, ind_N_2b);
    decision_base = decisionvector;

    while true

        % get decision at x maximum
        [ ind, ind_I_2a, ind_N_2a, ind_I_2b, ind_N_2b ] =            ...
        findOptimalDecision(x_upper, beta, parameters, t_1a, t_2a,   ...
            p_1a, p_2a, p_2b);
        [ decisionvector ] = createDecisionVector(ind, ind_I_2a, ...
                ind_N_2a, ind_I_2b, ind_N_2b);
        decision_max = decisionvector;

        % get decision at x minimum
        [ ind, ind_I_2a, ind_N_2a, ind_I_2b, ind_N_2b ] =            ...
        findOptimalDecision(x_lower, beta, parameters, t_1a, t_2a,   ...
            p_1a, p_2a, p_2b);
        [ decisionvector ] = createDecisionVector(ind, ind_I_2a, ...
                ind_N_2a, ind_I_2b, ind_N_2b);
        decision_min = decisionvector;

        % get decision at x mean
        x_mid = mean([x_lower, x_upper]);
        [ ind, ind_I_2a, ind_N_2a, ind_I_2b, ind_N_2b ] =            ...
        findOptimalDecision(x_mid, beta, parameters, t_1a, t_2a,   ...
            p_1a, p_2a, p_2b);
        [ decisionvector ] = createDecisionVector(ind, ind_I_2a, ...
                ind_N_2a, ind_I_2b, ind_N_2b);
        decision_mid = decisionvector;
        
        if x_upper - x_lower < error_tol
            decisionvector = decision_min;
            break;
        elseif all(decision_mid == decision_base)
            x_lower = x_mid;
            x_mid   = mean([x_lower, x_upper]);
        else 
            x_upper = x_mid;
            x_mid   = mean([x_lower, x_upper]);
        end
        debug = [debug; x_lower, x_mid, x_upper];
        
    end
end


function [ aggregates_1a, aggregates_2a, aggregates_2b ] =          ...
    updateAggregates( decisionvector, aggregates_1a, aggregates_2a, ...
    aggregates_2b, gamma, rho, I_1, I_2, pollution, employment, output)


    switch decisionvector(1)
        case 2

            % period one not investing
            aggregates_1a = aggregates_1a + [pollution; employment; output; 0];

            if decisionvector(2) == 2 	  % period 2a producing
                aggregates_2a = aggregates_2a + [pollution; employment; output; 0];
            elseif decisionvector(2) == 3 % period 2a investing
                aggregates_2a = aggregates_2a + [(1-gamma)*pollution; employment; ...
                                                 output; I_2*output];
            end                           % period 2a dropping

            if decisionvector(3) == 2     % period 2b producing
                aggregates_2b = aggregates_2b + [pollution; employment; output; 0];
            end                           % period 2b dropping

        case 3

            % period one investing
            aggregates_1a = aggregates_1a + [(1-gamma)*pollution; (1+rho)*employment; output; I_1*output];

            if decisionvector(2) == 2     % period 2a producing
                aggregates_2a = aggregates_2a + [(1-gamma)*pollution; (1+rho)*employment; output; 0];
            end                           % period 2a dropping

            if decisionvector(3) == 2     % period 2b producing
                aggregates_2b = aggregates_2b + [(1-gamma)*pollution; (1+rho)*employment; output; 0];
            end                           % period 2b dropping

        otherwise
            error('error in decision')
    end

end
