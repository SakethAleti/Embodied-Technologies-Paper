function [t_1a_opt, t_2a_opt, p_1a_opt, p_2a_opt, p_2b_opt] = ...
    optimizeTaxesPrices(parameters, p_guess, t_guess, M, N, ...
    tol_f, tax_1a_type, tax_2a_type)
% ========================================================================
% OPTIMIZETAXESPRICES Taxes are optimized by setting the present taxes 
% to a predefined tax type; this is the fixed point iteration method.
% Prices are optimized through the secant method. This requires two
% guesses: the first you can input in 'p_guess' and the latter is just
% randomly chosen to be close to your initial guess. 
% Each iteration involves optimizing the taxes and then optimizing the
% prices, so it is garaunteed that the final results at least have the
% correct prices
% ========================================================================
% INPUT ARGUMENTS:
%   parameters             (struct) generated by loadParameters
%   p_guess                (vector) initial guess for prices
%   t_guess                (vector) initial guess for taxes
%   M                      (int)    number of optimization iterations
%   N                      (int)    number of secant method 
%                                   optimization iterations
%   tol_f                  (func)   tolerance as a function of M
%   tax_1a_type            (string) pick from 'none', 'myopic', 'dynamic',
%                                   or 'optimal'
%   tax_2a_type            (string) pick from 'none' or 'pigouvian'
% ========================================================================
% OUTPUT:
%   t_1a_opt               (scalar) optimal period 1a tax
%   t_1a_opt               (scalar) optimal period 2a tax
%   p_1a_opt               (scalar) optimal period 1a price
%   p_2a_opt               (scalar) optimal period 2a price
%   p_2b_opt               (scalar) optimal period 2b price
% =========================================================================

%% Pre-lims

% debug structs
debug_off.taxes  = 0;
debug_off.prices = 0;
debug_on.prices = 1;
debug_on.taxes  = 1;

% set params to intial guesses
parameters.taxes_1a  = t_guess(1);
parameters.taxes_2a  = t_guess(2);
parameters.prices_1a = p_guess(1);
parameters.prices_2a = p_guess(2);
parameters.prices_2b = p_guess(3);


%% Main

% =============================Secant Method=============================
% Start with guesses x_0, x_1
% Estimate f'(x_1) using (f(x_1) - f(x_0))/(x_1 - x_0)
% Set x_2 = x_1 - f(x_1)/f'(x_1)
% Break if within tolerance or end of iterations
% Problems when f' close or equal to 0, in those cases, break early
% =======================================================================

fprintf(['\n\n' repmat('=', 1, 55) '\n' repmat('=', 1, 10) ...
    ' Running optimization procedure... ' repmat('=', 1, 10) '\n' ...
    repmat('=', 1, 55) '\n']);

for j = 1:M
    
    fprintf([repmat(' ', 1, 20) 'Iteration %i\n'], j);
    
    % set tolerance
    tol = tol_f(j);
    fprintf('\nSetting tolerance to: %f\n', tol)
    
    %% Optimize Period 1A tax

    x_est_0 = t_guess(1);
    x_est_1 = t_guess(1)*(1+randn()/100) + randn()/1000;

    fprintf('\nOptimizing Period 1A tax...\n')

    for i = 1:N

        parameters.taxes_1a = x_est_0;
        [~, tax_residual, ~, ~, pollution_aggregates, ~, ~, ~ ] =  ...
        runSimulationSingle( parameters, debug_off );
        [t_1a_opt, ~] = getOptimalTaxes(parameters, ...
        tax_residual, pollution_aggregates, tax_1a_type, tax_2a_type);
        f_at_est_0 = parameters.taxes_1a - t_1a_opt;

        parameters.taxes_1a = x_est_1;
        [~, tax_residual, ~, ~, pollution_aggregates, ~, ~, ~ ] =  ...
        runSimulationSingle( parameters, debug_off );
        [t_1a_opt, ~] = getOptimalTaxes(parameters, ...
        tax_residual, pollution_aggregates, tax_1a_type, tax_2a_type);
        f_at_est_1 = parameters.taxes_1a - t_1a_opt;

        f_diff_hat =  (f_at_est_1 - f_at_est_0)/(x_est_1 - x_est_0);

        if abs(f_diff_hat) < 1e-100 || isnan(f_diff_hat)
            x_est_new = x_est_1;
            parameters.taxes_1a = x_est_new;
            break
        else
            x_est_new = x_est_1 - (f_at_est_1)/(f_diff_hat);
        end    

        x_est_0 = x_est_1;
        x_est_1 = x_est_new;
        
        parameters.taxes_1a = x_est_new;
        [~, tax_residual, ~, ~, pollution_aggregates, ~, ~, ~ ] =  ...
        runSimulationSingle( parameters, debug_off );
        [t_1a_opt, ~] = getOptimalTaxes(parameters, ...
        tax_residual, pollution_aggregates, tax_1a_type, tax_2a_type);
        f_at_est_new = parameters.taxes_1a - t_1a_opt;
        
        fprintf('    Tax_Residual_1A: %f\n', f_at_est_new)
        if abs(f_at_est_new) < tol
            break
        end

    end
    
    %% Optimize Period 2A tax

    x_est_0 = t_guess(2);
    x_est_1 = t_guess(2)*(1+randn()/100) + randn()/1000;

    fprintf('\nOptimizing Period 2A tax...\n')

    for i = 1:N

        parameters.taxes_2a = x_est_0;
        [~, tax_residual, ~, ~, pollution_aggregates, ~, ~, ~ ] =  ...
        runSimulationSingle( parameters, debug_off );
        [~, t_2a_opt] = getOptimalTaxes(parameters, ...
        tax_residual, pollution_aggregates, tax_1a_type, tax_2a_type);
        f_at_est_0 = parameters.taxes_2a - t_2a_opt;

        parameters.taxes_2a = x_est_1;
        [~, tax_residual, ~, ~, pollution_aggregates, ~, ~, ~ ] =  ...
        runSimulationSingle( parameters, debug_off );
        [~, t_2a_opt] = getOptimalTaxes(parameters, ...
        tax_residual, pollution_aggregates, tax_1a_type, tax_2a_type);
        f_at_est_1 = parameters.taxes_2a - t_2a_opt;

        f_diff_hat =  (f_at_est_1 - f_at_est_0)/(x_est_1 - x_est_0);

        if abs(f_diff_hat) < 1e-100 || isnan(f_diff_hat)
            x_est_new = x_est_1;
            parameters.taxes_2a = x_est_new;
            break
        else
            x_est_new = x_est_1 - (f_at_est_1)/(f_diff_hat);
        end    

        x_est_0 = x_est_1;
        x_est_1 = x_est_new;
        
        parameters.taxes_2a = x_est_new;
        [~, tax_residual, ~, ~, pollution_aggregates, ~, ~, ~ ] =  ...
        runSimulationSingle( parameters, debug_off );
        [~, t_2a_opt] = getOptimalTaxes(parameters, ...
        tax_residual, pollution_aggregates, tax_1a_type, tax_2a_type);
        f_at_est_new = parameters.taxes_2a - t_2a_opt;
        
        fprintf('    Tax_Residual_1A: %f\n', f_at_est_new)
        if abs(f_at_est_new) < tol
            break
        end

    end
    
    %% Optimize Period 1A price

    x_est_0 = p_guess(1);
    x_est_1 = p_guess(1)*(1+randn()/100);

    fprintf('\nOptimizing Period 1A price...\n')

    for i = 1:N

        parameters.prices_1a = x_est_0;
        [~, ~, output_residual, ~, ~, ~, ~, ~] = ...
            runSimulationSingle( parameters, debug_off );
        f_at_est_0 = output_residual(1);

        parameters.prices_1a = x_est_1;
        [~, ~, output_residual, ~, ~, ~, ~, ~] = ...
            runSimulationSingle( parameters, debug_off );
        f_at_est_1 = output_residual(1);

        f_diff_hat =  (f_at_est_1 - f_at_est_0)/(x_est_1 - x_est_0);

        x_est_new = x_est_1 - (f_at_est_1)/(f_diff_hat);

        x_est_0 = x_est_1;
        x_est_1 = x_est_new;
        
        parameters.prices_1a = x_est_new;
        [~, ~, output_residual, ~, ~, ~, ~, ~] = ...
            runSimulationSingle( parameters, debug_off );
        f_at_est_new = output_residual(1);
        
        fprintf('    Output_Residual_1A: %f\n', f_at_est_new)
        if abs(f_at_est_new) < tol
            break
        end

    end


    %% Optimize Period 2A price

    x_est_0 = p_guess(2);
    x_est_1 = p_guess(2)*(1+randn()/100);
    
    fprintf('\nOptimizing Period 2A price...\n')

    for i = 1:N

        parameters.prices_2a = x_est_0;
        [~, ~, output_residual, ~, ~, ~, ~, ~] = ...
            runSimulationSingle( parameters, debug_off );
        f_at_est_0 = output_residual(2);

        parameters.prices_2a = x_est_1;
        [~, ~, output_residual, ~, ~, ~, ~, ~] = ...
            runSimulationSingle( parameters, debug_off );
        f_at_est_1 = output_residual(2);

        f_diff_hat =  (f_at_est_1 - f_at_est_0)/(x_est_1 - x_est_0);

        x_est_new = x_est_1 - (f_at_est_1)/(f_diff_hat);

        x_est_0 = x_est_1;
        x_est_1 = x_est_new;
        
        parameters.prices_2a = x_est_new;
        [~, ~, output_residual, ~, ~, ~, ~, ~] = ...
            runSimulationSingle( parameters, debug_off );
        f_at_est_new = output_residual(2);
        
        fprintf('    Output_Residual_2A: %f\n', f_at_est_new)
        if abs(f_at_est_new) < tol
            break
        end

    end


    %% Optimize Period 2B price

    x_est_0 = p_guess(2);
    x_est_1 = p_guess(2)*(1+randn()/100);

    fprintf('\nOptimizing Period 2B price...\n')

    for i = 1:N

        parameters.prices_2b = x_est_0;
        [~, ~, output_residual, ~, ~, ~, ~, ~] = ...
            runSimulationSingle( parameters, debug_off );
        f_at_est_0 = output_residual(3);

        parameters.prices_2b = x_est_1;
        [~, ~, output_residual, ~, ~, ~, ~, ~] = ...
            runSimulationSingle( parameters, debug_off );
        f_at_est_1 = output_residual(3);

        f_diff_hat =  (f_at_est_1 - f_at_est_0)/(x_est_1 - x_est_0);

        x_est_new = x_est_1 - (f_at_est_1)/(f_diff_hat);

        x_est_0 = x_est_1;
        x_est_1 = x_est_new;
        
        parameters.prices_2b = x_est_new;
        [~, ~, output_residual, ~, ~, ~, ~, ~] = ...
            runSimulationSingle( parameters, debug_off );
        f_at_est_new = output_residual(3);
        
        fprintf('    Output_Residual_2B: %f\n', f_at_est_new)
        if abs(f_at_est_new) < tol
            break
        end

    end
    
    %% Results of Iteration
    
    fprintf(['\nOptimization Results (Iteration %i)\n'], j);
    [~, tax_residual, ~, ~, ~, ~, ~, ~] = ...
        runSimulationSingle( parameters, debug_on );
    fprintf([repmat('-', 1, 55) '\n']);
    
    p_guess = [parameters.prices_1a, parameters.prices_2a, ...
        parameters.prices_2b];
    t_guess = [parameters.taxes_1a, parameters.taxes_2a];
    
end

%%  Optimization Results

t_1a_opt = parameters.taxes_1a;
t_2a_opt = parameters.taxes_2a;
p_1a_opt = parameters.prices_1a;
p_2a_opt = parameters.prices_2a;
p_2b_opt = parameters.prices_2b;

% Results
fprintf([repmat(' ', 1, 16)  'Optimization Complete\n'             ...
    repmat('-', 1, 55) '\nOptimal Taxes:\n    Period 1A: %f\n    ' ...
    'Period 2A: %f\nOptimal Prices:\n    Period 1A: %f\n    '      ...
    'Period 2A: %f\n    Period 2B: %f\n'], t_1a_opt, t_2a_opt,     ...
    p_1a_opt, p_2a_opt, p_2b_opt)

% Residual
[~, tax_residual, output_residual, ~, pollution_aggregates, ~, ~, ~ ] = ...
        runSimulationSingle( parameters, debug_off );
[t_1a_opt_2, t_2a_opt_2] = getOptimalTaxes(parameters, ...
    tax_residual, pollution_aggregates, tax_1a_type, tax_2a_type);
fprintf(['Tax Residual:\n    Period 1A: %f\n    ' ...
    'Period 2A: %f\nOutput Residual:\n    Period 1A: %f\n    '          ...
    'Period 2A: %f\n    Period 2B: %f\n'], t_1a_opt - t_1a_opt_2,       ...
    t_2a_opt - t_2a_opt_2, output_residual(1), output_residual(2),      ...
    output_residual(3))

end


%% Auxillary functions

function [t_1a_opt, t_2a_opt] = getOptimalTaxes(parameters, ...
    tax_residual, pollution_aggregates, tax_1a_type, tax_2a_type)

    switch tax_1a_type
        case 'none'
            t_1a_opt = 0;
        case 'myopic'
            t_1a_opt = parameters.xi*2*pollution_aggregates(1);
        case 'dynamic'
            t_1a_opt =                                       ...
                2*parameters.xi*pollution_aggregates(1) +               ...
                parameters.delta*(1-parameters.psi)*(parameters.alpha*2 ...
                *parameters.xi*pollution_aggregates(2) + (1-            ...
                parameters.alpha)*2*parameters.xi*pollution_aggregates(3));
        case 'optimal'
            t_1a_opt = parameters.taxes_1a - tax_residual(1);
        otherwise
            error('Unknown tax_1a_type')
    end
    
    switch tax_2a_type
        case 'none'
            t_2a_opt = 0;
        case 'pigouvian'
            t_2a_opt = parameters.taxes_2a - tax_residual(2);
        case 'optimal'
            t_2a_opt = parameters.taxes_2a - tax_residual(2);
        otherwise
            error('Unknown tax_2a_type')
    end
    
end